// //----------------------------------------수정 부분만 설명 -------------------------------------------//
/*메인 루프에서 항상 delay(20)을 했던것을  TIMER2 오버플로우 인터럽트로 수정 => 약20ms마다 틱 생성 -. 인터럽트 킴
아래 순서 */

// // 1) 인터럽트 헤더 추가
// #include <avr/io.h>
// #include <avr/interrupt.h>

// // 2) delay(20) 대체용 전역 플래그/카운터
// volatile uint8_t g_tick20ms = 0;
// volatile uint8_t g_ovf_cnt  = 0;

// // 3) Timer2 오버플로우 ISR (≈ 1.024ms/OVF, 20회 ≈ 20.48ms)
// ISR(TIMER2_OVF_vect) {
//   if (++g_ovf_cnt >= 20) {
//     g_ovf_cnt = 0;
//     g_tick20ms = 1;   // 20ms 틱 발생
//   }
// }

// // 4) setup() 내부: Timer2 OVF 인터럽트 활성화 + 전역 인터럽트 허용
// TIMSK2 |= (1<<TOIE2);   // Timer2 Overflow Interrupt Enable
// sei();

// // 5) loop() 맨 끝: 기존 delay(20) → 20ms 틱 플래그 대기
// while (!g_tick20ms) { /* 인터럽트가 g_tick20ms 세울 때까지 대기 */ }
// g_tick20ms = 0;
// // -------------------------------------------------------------------------------------------------//



#include <AltSoftSerial.h>
#include "UartQueue.h"
#include "PacketProtocol.h"
#include <avr/io.h>
#include <avr/interrupt.h>

// ===== CRC-8 (0x07) for upper 24 bits (bits 31..8) =====
static uint8_t crc8_24(uint32_t upper24) {
  uint8_t crc = 0x00;
  for (int i = 2; i >= 0; --i) {
    uint8_t b = (upper24 >> (i * 8)) & 0xFF;
    crc ^= b;
    for (uint8_t k = 0; k < 8; ++k) {
      if (crc & 0x80) crc = (crc << 1) ^ 0x07;
      else            crc <<= 1;
    }
  }
  return crc;
}

// ===== 전역 =====
const int DBG_LED_PIN = 7;
static uint8_t  g_tx_seqbit = 0;   // STATUS 전송 시 토글
static uint16_t crc_err_cnt = 0;   // CRC 오류 카운트

AltSoftSerial imuSerial;
#define IMU_SERIAL imuSerial
UartQueue rxQueue;

// --- delay(20) 대체용 타이머 인터럽트 플래그 ---
volatile uint8_t g_tick20ms = 0;
volatile uint8_t g_ovf_cnt  = 0;

void blinkOnce() {
  digitalWrite(DBG_LED_PIN, HIGH);
  delay(60);
  digitalWrite(DBG_LED_PIN, LOW);
  delay(40);
}

void blinkTwice() {
  for (int i = 0; i < 2; i++) {
    digitalWrite(DBG_LED_PIN, HIGH);
    delay(60);
    digitalWrite(DBG_LED_PIN, LOW);
    delay(40);
  }
}

void blinkThree() {
  for (int i = 0; i < 3; i++) {
    digitalWrite(DBG_LED_PIN, HIGH);
    delay(50);
    digitalWrite(DBG_LED_PIN, LOW);
    delay(40);
  }
}

// ===== 핀 매핑 =====
#define ENA 3
#define IN1 4
#define IN2 5
#define ENB 11
#define IN3 12
#define IN4 13

// ===== 비트 마스크 (UNO) =====
#define IN1_BIT _BV(PD4)  // D4
#define IN2_BIT _BV(PD5)  // D5
#define IN3_BIT _BV(PB4)  // D12
#define IN4_BIT _BV(PB5)  // D13

// ===== IMU 구조체 =====
struct SAngle { float Roll, Pitch, Yaw; };
struct SAcc   { float X, Y, Z; };
struct SGyro  { float X, Y, Z; };
SAngle stcAngle; SAcc stcAcc; SGyro stcGyro;
float Axyz[3] = {0}, Gxyz[3] = {0};

// ===== 헤딩/상태 =====
float currentHeading = 0.0f, initialHeading = 0.0f, targetAngle = 0.0f;
int   targetSpeed = 0;
bool  newCommandReceived = false;
float yawZeroOffset = 0.0f, lastOutYaw = 0.0f;

enum RobotState { IDLE, ROTATING, MOVING };
RobotState currentState = IDLE;
unsigned long moveStartTime = 0;

// ===== PID =====
float Kp = 4.0f, Ki = 0.0f, Kd = 0.1f;

// ===== 모터 파라미터 =====
const int MIN_PWM = 180;
const int MIN_ROTATE_PWM = 110;
const int MAX_PWM = 250;
const int MAX_MOVE_PWM = 255;
const int INITIAL_MOVE_SPEED = 250;
const int INITIAL_MOVE_DURATION = 10;
const unsigned long MOVE_DURATION = 2000;

// ===== UART & 디버그 =====
#define UART_BAUD_RATE 9600
#define DEBUG 0
unsigned long lastDbgMs = 0;
const unsigned long DBG_PERIOD_MS = 200;
uint32_t accCnt = 0, gyrCnt = 0, angCnt = 0, lastCountMs = 0;

// ===== 유틸 =====
static inline float wrap360(float a) { while (a < 0) a += 360; while (a >= 360) a -= 360; return a; }
static inline float angleDiff(float t, float c) { float d = t - c; while (d > 180) d -= 360; while (d < -180) d += 360; return d; }
const float ANGLE_DEADBAND = 3.0f;
bool  moving = false;
const float LPF_ALPHA = 0.25f;

void sendCompletionStatus() {
  uint32_t statusPacket = (1UL << 9);

  g_tx_seqbit ^= 1;
  statusPacket |= (uint32_t)(g_tx_seqbit & 0x1) << 8;

  uint8_t crc = crc8_24(statusPacket >> 8);
  statusPacket |= crc;

  uint8_t bytes[4];
  bytes[0] = (statusPacket >> 24) & 0xFF;
  bytes[1] = (statusPacket >> 16) & 0xFF;
  bytes[2] = (statusPacket >> 8)  & 0xFF;
  bytes[3] = statusPacket & 0xFF;

  Serial.write(bytes, 4);
  Serial.flush();

  blinkTwice();
}

void dbgPrintStateLine(const char* tag, float err) {
  if (!DEBUG) return;
  Serial.print(tag); Serial.print(" | STATE=");
  Serial.print((int)currentState);
  Serial.print(" v=");  Serial.print(targetSpeed);
  Serial.print(" hdg="); Serial.print(currentHeading, 1);
  Serial.print(" tgt="); Serial.print(targetAngle, 1);
  Serial.print(" err="); Serial.println(err, 1);
}

// ===== 모터 제어 (Timer2 PWM: D3=OC2B, D11=OC2A) =====
void forwardKick(uint8_t pwm, uint16_t ms) {
  // 이 프로젝트는 전진이 (-)로 들어가 있으니까 그대로 맞춰
  driveOneMotor(ENA, IN1, IN2, -pwm);
  driveOneMotor(ENB, IN3, IN4, -pwm);
  delay(ms);
}


void driveOneMotor(int EN_pin, int IN1_pin, int IN2_pin, int speed) {
  int pwmValue = abs(constrain(speed, -255, 255));

  if (EN_pin == ENA) {                       // 왼쪽
    if (speed > 0)      { PORTD |= IN1_BIT; PORTD &= ~IN2_BIT; } // D4=H, D5=L
    else if (speed < 0) { PORTD &= ~IN1_BIT; PORTD |= IN2_BIT; } // D4=L, D5=H
    else                { PORTD &= ~(IN1_BIT | IN2_BIT); }       // D4=L, D5=L
    OCR2B = pwmValue;                                           // D3 PWM
  } else if (EN_pin == ENB) {                // 오른쪽
    if (speed > 0)      { PORTB |= IN3_BIT; PORTB &= ~IN4_BIT; } // D12=H, D13=L
    else if (speed < 0) { PORTB &= ~IN3_BIT; PORTB |= IN4_BIT; } // D12=L, D13=H
    else                { PORTB &= ~(IN3_BIT | IN4_BIT); }       // D12=L, D13=L
    OCR2A = pwmValue;                                           // D11 PWM
  }
}

void setMotorSpeedDifferential(int leftSpeed, int rightSpeed) {
  leftSpeed  = constrain(leftSpeed,  -MAX_PWM, MAX_PWM);
  rightSpeed = constrain(rightSpeed, -MAX_PWM, MAX_PWM);
  moving = (abs(leftSpeed) >= MIN_PWM || abs(rightSpeed) >= MIN_PWM);

  if (!moving) {
    driveOneMotor(ENA, IN1, IN2, 0);
    driveOneMotor(ENB, IN3, IN4, 0);
    return;
  }
  if (abs(leftSpeed)  < MIN_PWM && leftSpeed  != 0) leftSpeed  = (leftSpeed  > 0) ? MIN_PWM : -MIN_PWM;
  if (abs(rightSpeed) < MIN_PWM && rightSpeed != 0) rightSpeed = (rightSpeed > 0) ? MIN_PWM : -MIN_PWM;

  driveOneMotor(ENA, IN1, IN2, leftSpeed);
  driveOneMotor(ENB, IN3, IN4, rightSpeed);
}

void setMotorSpeedDifferentialWithMin(int leftSpeed, int rightSpeed, int minPwm) {
  leftSpeed  = constrain(leftSpeed,  -MAX_PWM, MAX_PWM);
  rightSpeed = constrain(rightSpeed, -MAX_PWM, MAX_PWM);
  moving = (abs(leftSpeed) >= minPwm || abs(rightSpeed) >= minPwm);

  if (!moving) {
    driveOneMotor(ENA, IN1, IN2, 0);
    driveOneMotor(ENB, IN3, IN4, 0);
    return;
  }
  if (abs(leftSpeed)  < minPwm && leftSpeed  != 0) leftSpeed  = (leftSpeed  > 0) ? minPwm : -minPwm;
  if (abs(rightSpeed) < minPwm && rightSpeed != 0) rightSpeed = (rightSpeed > 0) ? minPwm : -minPwm;

  driveOneMotor(ENA, IN1, IN2, leftSpeed);
  driveOneMotor(ENB, IN3, IN4, rightSpeed);
}

void moveAtSpeed(int speed) {
  speed = constrain(speed, -MAX_MOVE_PWM, MAX_MOVE_PWM);
  int corrected_left  = -speed;
  int corrected_right = -speed;   // 예시 보정
  moving = (abs(corrected_left) >= MIN_PWM || abs(corrected_right) >= MIN_PWM);
  driveOneMotor(ENA, IN1, IN2, corrected_left);
  driveOneMotor(ENB, IN3, IN4, corrected_right);
}

// ===== WT901 =====
const unsigned long WT901_BAUD = 9600;
uint8_t imuFrame[11]; uint8_t imuIdx = 0;

inline bool wt901CheckSumOK(const uint8_t* f) {
  uint8_t s = 0; for (int i = 0; i < 10; ++i) s += f[i]; return (s == f[10]);
}
void imuSetup() { IMU_SERIAL.begin(WT901_BAUD); }

void imuPollWT901() {
  while (IMU_SERIAL.available()) {
    uint8_t c = (uint8_t)IMU_SERIAL.read();
    if (imuIdx == 0) {
      if (c != 0x55) continue;
      imuFrame[imuIdx++] = c;
      continue;
    }

    imuFrame[imuIdx++] = c;
    if (imuIdx == 2) {
      if (imuFrame[1] != 0x51 && imuFrame[1] != 0x52 && imuFrame[1] != 0x53) {
        imuIdx = (c == 0x55) ? 1 : 0;
      }
    }

    if (imuIdx == 11) {
      imuIdx = 0;
      if (!wt901CheckSumOK(imuFrame)) continue;

      auto s16 = [&](int lo, int hi) -> int16_t {
        return (int16_t)(((uint16_t)imuFrame[hi] << 8) | (uint16_t)imuFrame[lo]);
      };

      if (imuFrame[1] == 0x51) { // 가속도
        stcAcc.X = (float)s16(2, 3) / 32768.0f * 16.0f;
        stcAcc.Y = (float)s16(4, 5) / 32768.0f * 16.0f;
        stcAcc.Z = (float)s16(6, 7) / 32768.0f * 16.0f;
        Axyz[0] = stcAcc.X; Axyz[1] = stcAcc.Y; Axyz[2] = stcAcc.Z;
        accCnt++;
      } else if (imuFrame[1] == 0x52) { // 각속도
        stcGyro.X = (float)s16(2, 3) / 32768.0f * 2000.0f;
        stcGyro.Y = (float)s16(4, 5) / 32768.0f * 2000.0f;
        stcGyro.Z = (float)s16(6, 7) / 32768.0f * 2000.0f;
        Gxyz[0] = stcGyro.X; Gxyz[1] = stcGyro.Y; Gxyz[2] = stcGyro.Z;
        gyrCnt++;
      } else if (imuFrame[1] == 0x53) { // 각도
        stcAngle.Roll  = (float)s16(2, 3) / 32768.0f * 180.0f;
        stcAngle.Pitch = (float)s16(4, 5) / 32768.0f * 180.0f;
        stcAngle.Yaw   = (float)s16(6, 7) / 32768.0f * 180.0f;
        angCnt++;
      }
    }
  }
}

void imuUpdate() { imuPollWT901(); }

void updateHeadingFused() {
  static bool init = true;
  static float outYaw = 0.0f;

  float rawYaw360 = wrap360(stcAngle.Yaw < 0 ? (stcAngle.Yaw + 360.0f) : stcAngle.Yaw);
  float measured  = rawYaw360;

  if (init) {
    outYaw = measured;
    init = false;
  } else {
    float d = angleDiff(measured, outYaw);
    outYaw = wrap360(outYaw + LPF_ALPHA * d);
  }

  lastOutYaw      = outYaw;
  currentHeading  = wrap360(outYaw - yawZeroOffset);
}

// ===== PID 회전 =====
bool rotateToAbsAngle(float targetAbsAngle) {
  const float CLOSE_DEG = 25.0f;
  float integral  = 0.0f;
  float lastError = 0.0f;

  unsigned long startMs = millis();
  unsigned long lastUs  = micros();

  while (true) {
    if (millis() - startMs > 15000UL) {
      setMotorSpeedDifferential(0,0);
      return false;
    }

    imuUpdate();
    updateHeadingFused();

    float heading_now = currentHeading;
    float error       = angleDiff(targetAbsAngle, heading_now);

    unsigned long nowUs = micros();
    float dt = (nowUs - lastUs) / 1000000.0f;
    lastUs = nowUs;
    if (dt <= 0) dt = 0.01f;

    if (abs(error) <= ANGLE_DEADBAND) {
      setMotorSpeedDifferential(0,0);
      return true;
    }

    integral += error * dt;
    float derivative = (error - lastError) / dt;
    lastError = error;

    int correction = (int)round(Kp * error + Ki * integral + Kd * derivative);

    int minPwm = MIN_ROTATE_PWM;
    if (abs(error) < CLOSE_DEG) {
      correction /= 2;
      if (correction == 0) correction = (error > 0) ? 40 : -40;
      minPwm = 50;
    }

    if (abs(correction) < minPwm)
      correction = (correction > 0) ? minPwm : -minPwm;
    correction = constrain(correction, -MAX_PWM, MAX_PWM);

    int leftSpeed, rightSpeed;
    if (error > 0) {
      // +각도만 좀 약하게
      int scaled = (abs(correction) * 7) / 10;
      if (scaled < minPwm) scaled = minPwm;
      leftSpeed  =  scaled;
      rightSpeed = -scaled;
    } else {
      leftSpeed  = -abs(correction);
      rightSpeed =  abs(correction);
    }

    setMotorSpeedDifferentialWithMin(leftSpeed, rightSpeed, minPwm);
    delay(10);
  }
}


// ===== 비트/디버깅 유틸 =====
uint8_t reverseBits(uint8_t b) {
  b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
  b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
  b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
  return b;
}

void printBinary32(uint32_t value) {
  for (int i = 31; i >= 0; i--) {
    Serial.print((value >> i) & 1);
    if (i % 4 == 0) Serial.print(" ");
  }
}

// ===== Timer2 OVF ISR (≈1.024 ms/OVF, 20회 ≈ 20.48 ms) =====
ISR(TIMER2_OVF_vect) {
  if (++g_ovf_cnt >= 20) {
    g_ovf_cnt = 0;
    g_tick20ms = 1;
  }
}

// ===== setup =====
void setup() {
  pinMode(DBG_LED_PIN, OUTPUT);
  digitalWrite(DBG_LED_PIN, LOW);

  // 1) UART
  Serial.begin(UART_BAUD_RATE);

  // 2) IMU
  imuSetup();

  // 3) 모터 핀 (레지스터)
  DDRD |= IN1_BIT | IN2_BIT | _BV(PD3); // D4, D5, D3(ENA)
  DDRB |= IN3_BIT | IN4_BIT | _BV(PB3); // D12, D13, D11(ENB)

  PORTD &= ~(IN1_BIT | IN2_BIT);
  PORTB &= ~(IN3_BIT | IN4_BIT);

  // 4) Timer2: Fast PWM + prescaler 64 + OVF 인터럽트
  TCCR2A = 0;
  TCCR2B = 0;
  TCCR2A |= (1 << WGM21) | (1 << WGM20);     // Fast PWM
  TCCR2A |= (1 << COM2A1) | (1 << COM2B1);   // non-inverting
  TCCR2B |= (1 << CS22);                     // prescaler = 64

  OCR2A = 0;  // D11 PWM
  OCR2B = 0;  // D3  PWM

  TIMSK2 |= (1 << TOIE2);                    // OVF 인터럽트 허용
  sei();                                     // 전역 인터럽트

  // 5) 워밍업
  moveAtSpeed(INITIAL_MOVE_SPEED);
  delay(INITIAL_MOVE_DURATION);
  moveAtSpeed(0);
  delay(500);

  // 6) 초기 헤딩 정렬
  unsigned long t0 = millis();
  uint16_t angSamples = 0;
  float lastYawSample = 9999.0f;

  if (DEBUG) Serial.print("Waiting for stable IMU angle data...");
  while (millis() - t0 < 2000) {
    imuUpdate();
    updateHeadingFused();

    if (stcAngle.Yaw != lastYawSample) {
      lastYawSample = stcAngle.Yaw;
      angSamples++;
      if (DEBUG) Serial.print(".");
      if (angSamples >= 5) break;
    }
    delay(10);
  }
  if (DEBUG) Serial.println(" OK.");

  yawZeroOffset   = lastOutYaw;
  updateHeadingFused();
  initialHeading  = currentHeading;
  targetAngle     = initialHeading;

  setMotorSpeedDifferential(0, 0);
  moveAtSpeed(0);
  currentState        = IDLE;
  newCommandReceived  = false;
  targetSpeed         = 0;

  if (DEBUG) Serial.println("Setup complete. Robot stopped. Waiting for command...");
}
void loop() {
  // 1) 시리얼에서 들어오는 바이트 → 비트리버스 → 큐에 넣기
  while (Serial.available()) {
    uint8_t b = reverseBits((uint8_t)Serial.read());
    rxQueue.enqueue(b);
  }

  // 2) 4바이트 패킷이 준비됐으면 처리
  while (rxQueue.getLength() >= 4) {
    uint8_t b1, b2, b3, b4;
    rxQueue.dequeue(b1);   // LSB쪽부터 들어있지만 우리는 두 번 리버스할 거라 OK
    rxQueue.dequeue(b2);
    rxQueue.dequeue(b3);
    rxQueue.dequeue(b4);

    // 두 번째 비트 리버스 (원래 모양으로)
    uint8_t r1 = reverseBits(b1);
    uint8_t r2 = reverseBits(b2);
    uint8_t r3 = reverseBits(b3);
    uint8_t r4 = reverseBits(b4);

    // MSB first로 조립
    uint32_t packet =
        ((uint32_t)r1 << 24) |
        ((uint32_t)r2 << 16) |
        ((uint32_t)r3 << 8)  |
        (uint32_t)r4;

    // CRC 확인
    uint8_t  rx_crc   = packet & 0xFF;     // [7:0]
    uint32_t upper24  = packet >> 8;       // [31:8]
    uint8_t  calc_crc = crc8_24(upper24);

    if (rx_crc != 0x00 && rx_crc != calc_crc) {
      // 깨진 패킷
      crc_err_cnt++;
      blinkThree();
      continue;   // 다음 4바이트 보자
    }

    uint8_t speed_type = (upper24 >> 22) & 0x03;  // 23..22
    uint8_t speed_val  = (upper24 >> 14) & 0xFF;  // 21..14
    uint8_t angle_type = (upper24 >> 12) & 0x03;  // 13..12
    uint8_t angle_val  = (upper24 >> 4)  & 0xFF;  // 11..4

    blinkOnce();   // “패킷 하나 받았다” 표시


    // 2) 여기서부터가 진짜 우리가 쓸 값
    int   new_v = 0;
    float new_a = 0.0f;

    // --- 속도 해석 ---
    // radar_ver1.py가 speed_type을 0b01로 보내니까 그거면 그냥 PWM으로 씀.
    if (speed_type == 0x01) {          // 01 = "속도값 하나"
      new_v = speed_val;               // 0~255 그대로
    } else {
      new_v = 0;                       // 다른 타입은 일단 0 처리
    }

    // --- 각도 해석 ---
    // radar_ver1.py가 angle을 0b10로 보내고, 음수일 때는 2의 보수(= &0xFF)로 보내니까
    // 여기서 int8_t 로 다시 부호를 살려줘야 함.
    if (angle_type == 0x02) {          // 10b = 0x02
      int8_t ang8 = (int8_t)angle_val; // 예: PC에서 -10보내면 여기서 -10나옴
      new_a = (float)ang8;             // 단위: degree
    } else {
      new_a = 0.0f;
    }

    // ---------- 정상 세그먼트면 상태머신에 명령 넣기 ----------
    if (new_v > 0 || new_a != 0.0f) {
      targetSpeed = constrain(new_v, 0, MAX_MOVE_PWM);
      // 상대각 → 절대각
      targetAngle = wrap360(currentHeading + new_a);

      // 실행 전에 일단 정지
      setMotorSpeedDifferential(0, 0);
      moveAtSpeed(0);

      // 지금 헤딩 다시 읽고…
      imuUpdate();
      updateHeadingFused();
      float err = angleDiff(targetAngle, currentHeading);

      if (abs(err) <= ANGLE_DEADBAND) {
        // 회전 거의 안 해도 되는 경우 → 그냥 앞으로
        if (targetSpeed > 0) {
          currentState  = MOVING;
          moveStartTime = millis();
          moveAtSpeed(max(targetSpeed, MIN_PWM));
        } else {
          currentState = IDLE;
          // 이 경우도 사실 STATUS 보내도 되는데,
          // 여기선 “진짜 아무 동작 없음” 케이스라 패스
        }
      } else {
        // 회전부터 해야 하는 경우
        newCommandReceived = true;
        currentState       = ROTATING;
      }
    } // end “정상 세그먼트”
  } // end while (rxQueue.getLength() >= 4)

  // 3) 상태머신 실행
  switch (currentState) {
    case IDLE:
      // 아무것도 안 함
      break;

    case ROTATING: {
      if (newCommandReceived) {
        newCommandReceived = false;

        imuUpdate();
        updateHeadingFused();

        // 혹시 이미 근처면 바로 MOVING/IDLE
        if (abs(angleDiff(targetAngle, currentHeading)) <= ANGLE_DEADBAND) {
          if (targetSpeed > 0) {
            currentState  = MOVING;
            moveStartTime = millis();
            moveAtSpeed(max(targetSpeed, MIN_PWM));
          } else {
            currentState = IDLE;
            sendCompletionStatus();    // ★ 회전만 시킨 세그먼트였음 → 끝났다고 올리기
          }
          break;
        }

        // 진짜로 회전
        bool ok = rotateToAbsAngle(targetAngle);
        if (ok) {
          if (targetSpeed > 0) {
            currentState  = MOVING;
            moveStartTime = millis();

            forwardKick(255, 120);  // 120ms 정도 풀 PWM
            moveAtSpeed(max(targetSpeed, MIN_PWM));
          } else {
            currentState = IDLE;
            sendCompletionStatus();    // ★ 성공적으로 돌고 끝
          }
        } else {
          currentState = IDLE;
          sendCompletionStatus();      // ★ 실패해도 위로는 끝났다고 올림
        }
      }
      break;
    }

    case MOVING:
      if (millis() - moveStartTime >= MOVE_DURATION) {
        moveAtSpeed(0);
        currentState = IDLE;
        sendCompletionStatus();        // ★ 2초 주행 끝
      }
      break;
  }

  // 4) 센서 계속
  imuUpdate();
  updateHeadingFused();

  // 5) (네가 쓰던) 1초마다 카운터 리셋 같은 거 있으면 여기
  if (millis() - lastCountMs >= 1000) {
    lastCountMs = millis();
    accCnt = gyrCnt = angCnt = 0;
  }

  delay(20);
}
